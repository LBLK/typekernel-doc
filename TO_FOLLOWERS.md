# 给后来者的话

亲爱的后来者：

欢迎你来到这里，一边观赏着我们这些前人的遗迹，一边思考着OS开发的奥秘。

这个项目起源于一个非常简单的想法：使用C++和Rust开发OS内核都让人觉得有些不对劲。如果你认真完成了《操作系统》这门课程的任务，这应该是非常显然的。

总的来说，设计一门编程语言就是在许多特性中作出取舍：强类型还是弱类型？静态类型还是动态类型？偏向面向对象，面向过程，还是更加偏向函数式编程？需不需要运行时和垃圾回收机制？允不允许用户对直接操纵内存地址？

对每一个特性来说，在某种场景下它是垫脚石，在其他场景下则是绊脚石。合格的语言设计者会谨慎地考虑自己的语言会被用作什么用途，然后谨慎地选择要添加的特性。

问题在于，OS内核开发，本身就不能被简单地归纳为一个单一的场景。

有时，我们希望我们能生成完全无需运行时的代码，希望能精准地控制内存访问，希望能生成和汇编语言协同工作的代码。例如：bootloader、trap handler、device driver。

又有时，我们会觉得以上特性并非必须，只要能方便的描述算法就好。例如：线程调度。

又有时，我们会希望能够使用一些面向对象的特性。例如：开发模块化内核时，或者给不同设备驱动或者文件系统提供同样的抽象接口。

……

这些需求“喜欢”和“讨厌”的语言特性各不相同，甚至互相矛盾，但它们都是内核的组成部分。如果使用单一语言开发，会不可避免地在某些时候望天长啸：为什么我会选择这种语言？

要解决这个问题，可以有如下方案：

1. 成为大牛，用任何语言写任何程序都觉得顺手。

2. 不解决，憋着。因为这个问题并没有严重影响开发，如果你擅长忍耐，那么忍一忍就过去了。

3. 除去以上两个玩笑一般，但确实是最常见的应对方法，你可以尝试使用多种语言开发内核，并且让它们协同工作。

    > **问题1**：
    >
    > a) 什么情况下多种语言可以协同工作？已知汇编，C，C++可以非常方便地共同开发和运行，原因是什么？
    >
    > b) Rust也可以和上述语言比较方便地共同开发和运行，机制是什么？
    >
    > c) 如果要Python，Java，C#之类的语言和汇编，C，C++共同开发和运行，有哪些难点？使用这种方法开发OS内核可行吗？

4. 你也可以选择微内核架构，把内核的某些部分放到用户态。这些部分可以非常方便地使用不同的语言开发。

    > **问题2**：
    >
    > a) 微内核相比宏内核缺点在哪里？为了解决这些缺点，人们做出了哪些努力？
    >
    > b) 通过微内核架构，能够有效解决OS内核开发不同场景需要不同语言特性的问题吗？

5. 或者是，尝试设计一门神奇的语言，它能够适应OS内核开发的所有——至少是几乎所有——场景。

    > **问题3**：
    >
    > a) 这门语言需要直面我们提出的问题：OS内核开发不同场景需要不同语言特性。对于语言特性，“我全都要”是一个不科学也不合理的要求。相反，如果我们能操控语言特性在编译某些部分时打开，又在编译另一些部分时关闭，可能是一个更合理的方案。“可开关的语言特性”应该如何实现？存在现有的语言满足或者部分满足这个要求吗？这样的做法会不会带来新的难点和风险？
    >
    > b) 你可能发现，在大部分现有的实用的编程语言中，对“可开关的语言特性”都提供了非常有限度的支持。这些支持是不是弱到满足不了我们的需求？如果要借鉴它们的实现方法，你有什么想法？

6. 最后，也许你有自己的解决方案……

    > **问题4**：
    >
    > a) 是否存在另外的一种方案，解决“OS内核开发不同场景需要不同语言特性”的问题？

我们不是第一批思考这些问题的人，也不会是最后一批。这并不是一个紧迫而致命的问题——我在上面写到，现在的开发者，可以选择成为大牛，也可以选择忍着——但这仍是一个值得思考的问题。这个问题的解答不仅惠及OS内核开发，也惠及其他像OS内核开发一样，复杂到各部分需要不同的语言特性的场景；尽管它们和OS内核开发不尽相同（这是**问题5**：这样的场景还有哪些？在这些场景下，人们是如何解决这个问题的？）。

我们已经帮你排除了一条不甚正确的路，如果你愿意思考这个问题，祝你好运。

アールケグズ，携队友gjz010与NagiNikaido 敬上
